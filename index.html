<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

        <title>Babylon.js sample code</title>

        <!-- Babylon.js -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
        <script src="https://assets.babylonjs.com/generated/Assets.js"></script>
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://preview.babylonjs.com/cannon.js"></script>
        <script src="https://preview.babylonjs.com/Oimo.js"></script>
        <script src="https://preview.babylonjs.com/earcut.min.js"></script>
        <script src="https://preview.babylonjs.com/babylon.js"></script>
        <script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
        <script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
        <script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.js"></script>
        <script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/uuid/8.3.2/uuid.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.5.0/socket.io.min.js"></script>
        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }

            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        /*INITIAL*/

var scene;
const id = uuid.v4();
    let socket = io.connect( "ws://localhost:5000", { query:`id=${id}`,transports: ['websocket'] } );
    socket.on('connect', () => {
      localStorage.setItem('id', id);
      socket.emit('add-cube', { id: id, position: { x: 0, y: 0.75, z: 0} });
    });

    socket.on('get-cubes', data => {
      loadCubes(data)
    })




    function loadCube(sceneP, cube) {
      if (cube.id === id) return null;
       let c = sceneP.getMeshByName(cube.id);
       c.position = cube.position;
       c.rotation = {
        x: cube.rotation._x,
        y: cube.rotation._y,
        z: cube.rotation._z,
       }
       //c.rotation = cube.rotation;
    }

    function loadCubes(cubes) {
       cubes.forEach(c => {
        if (c.id !== id ) {
          var cubePlayer = new BABYLON.MeshBuilder.CreateBox(c.id, {
            height: 1.5,
            depth: 2,
            width: 2
          }, scene);
          var cubePlayerMaterial = new BABYLON.StandardMaterial("cubePlayerMaterial", scene);
          cubePlayerMaterial.diffuseColor = new BABYLON.Color3(1, 0, 5);

          cubePlayer.material = cubePlayerMaterial
          cubePlayer.position.y = c.position.y;
          cubePlayer.position.x = c.position.x;
          cubePlayer.position.z = c.position.z;

          cubePlayer.rotation.y = c.rotation.y;
          cubePlayer.rotation.x = c.rotation.x;
          cubePlayer.rotation.z = c.rotation.z;

          cubePlayer.speed = 0.5;
          cubePlayer.frontVector = new BABYLON.Vector3(0, 0, 1);
          cubePlayer.checkCollisions = true;
        }
      })
    }



        /*INITIAL*/
        window.addEventListener('DOMContentLoaded', function () {
            // get the canvas DOM element
  var canvas = document.getElementById('renderCanvas');

// load the 3D engine
var engine = new BABYLON.Engine(canvas, true);


var createFollowCamera = function(scene, canvas, target) {
  var camera = new BABYLON.FollowCamera("tankFollowCamera", new BABYLON.Vector3(10, 0, 10), scene);
  camera.heightOffset = 10;
  camera.rotationOffset = 180;
  camera.cameraAcceleration = .1;
  camera.maxCameraSpeed = 1;
  camera.fov = 1.25;
  camera.lockedTarget = target;
  camera.attachControl(canvas, true);
  camera.inputs.removeByType('FollowCameraPointersInput');
  return camera;
}


// createScene function that creates and return the scene
var createScene = () => {
  scene = new BABYLON.Scene(engine);
socket.on('move-player', data => {
      loadCube(scene,data)
    })

    socket.on('remove-cube', id => {
      let c = scene.getMeshByName(id);
      c.dispose();
    })
  var light = new BABYLON.HemisphericLight("HemiLight", new BABYLON.Vector3(0, 1, 0), scene);

  // Ground
  const ground = BABYLON.Mesh.CreateGround("ground", 100, 50, 1, scene, false);
  var groundMaterial = new BABYLON.StandardMaterial("ground", scene);
  groundMaterial.diffuseTexture = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/grass.png", scene);
  groundMaterial.diffuseTexture.uScale = 6;
  groundMaterial.diffuseTexture.vScale = 6;
  groundMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
  ground.position.y = 0;
  ground.material = groundMaterial;

  // Skybox
  var skybox = BABYLON.Mesh.CreateBox("skyBox", 1000.0, scene);
  var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
  skyboxMaterial.backFaceCulling = false;
  skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("https://www.babylonjs-playground.com/textures/TropicalSunnyDay", scene);
  skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
  skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
  skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
  skyboxMaterial.disableLighting = true;
  skybox.material = skyboxMaterial;


  var tank = new BABYLON.MeshBuilder.CreateBox("tank", {
    height: 1.5,
    depth: 2,
    width: 2
  }, scene);
  var tankMaterial = new BABYLON.StandardMaterial("tankMaterial", scene);
  tankMaterial.diffuseColor = new BABYLON.Color3(1, 0, 5);

  tank.material = tankMaterial
  tank.position.y = 0.75;
  tank.speed = 0.2;
  tank.frontVector = new BABYLON.Vector3(0, 0, 1);
  tank.checkCollisions = true;



  BABYLON.SceneLoader.ImportMesh("", "./scenes/", "full2.glb", scene, function (newMeshes,  particleSystems, skeletons) {
    var skeleton = skeletons[0];
    
    var agMap = {};
    var allAGs = scene.animationGroups;
    for (i = 0; i < allAGs.length; i++) {
      agMap[allAGs[i].name] = allAGs[i];
    }
    allAGs[0].stop();
    allAGs[1].stop();
    allAGs[2].stop();
});


  //create walls
  var wall = [];
  let GreenColor = new BABYLON.Color4(0, 255, 0, 0.5);
  let RedColor = new BABYLON.Color4(255, 0, 0, 0.5);
  let BlueColor = new BABYLON.Color4(0, 0, 255, 0.5);
  let arrGreenColor = [];
  let arrRedColor = [];
  let arrBlueColor = [];
  arrGreenColor.length = 6;
  arrRedColor.length = 6;
  arrBlueColor.length = 6;
  arrGreenColor.fill(GreenColor);
  arrRedColor.fill(RedColor);
  arrBlueColor.fill(BlueColor);

  //wall 1
  wall[0] = new BABYLON.MeshBuilder.CreateBox("wall 1",
    {
      width: 50, 
      faceColors: arrBlueColor, 
      height: 6, 
      depth: 0.6,
    },
    scene);
  wall[0].position.x = 50;
  wall[0].position.y = 3;
  wall[0].rotation.y = 300.01;
  wall[0].checkCollisions = true;

  //wall 2
  wall[1] = new BABYLON.MeshBuilder.CreateBox("wall 2",
    {
      width: 50, 
      faceColors: arrGreenColor, 
      height: 6, 
      depth: 0.6,
    },
    scene);
  wall[1].position.x = -50;
  wall[1].position.y = 3;
  wall[1].rotation.y = 300.01;
  wall[1].checkCollisions = true;

  //wall 3
  wall[2] = new BABYLON.MeshBuilder.CreateBox("wall 3",
    {
      width: 100, 
      faceColors: arrGreenColor, 
      height: 6, 
      depth: 0.6,
    },
    scene);
  wall[2].position.z = 25;
  wall[2].position.y = 3;
  wall[2].checkCollisions = true;

  //wall 4
  wall[3] = new BABYLON.MeshBuilder.CreateBox("wall 4",
    {
      width: 100, 
      faceColors: arrGreenColor, 
      height: 6, 
      depth: 0.6,
    },
    scene);
  wall[3].position.z = -25;
  wall[3].position.y = 3;
  wall[3].checkCollisions = true;

  //wall middle left 
  wall[4] = new BABYLON.MeshBuilder.CreateBox("wall middle left",
    {
      width: 20, 
      faceColors: arrRedColor, 
      height: 6, 
      depth: 0.6,
    },
    scene);
  wall[4].position.x = 0;
  wall[4].position.z = -15;
  wall[4].position.y = 3;
  wall[4].rotation.y = 300.01;
  wall[4].checkCollisions = true;

  //wall middle right
  wall[5] = new BABYLON.MeshBuilder.CreateBox("wall middle right",
    {
      width: 20, 
      faceColors: arrRedColor, 
      height: 6, 
      depth: 0.6,
    },
    scene);
  wall[5].position.x = 0;
  wall[5].position.z = 15;
  wall[5].position.y = 3;
  wall[5].rotation.y = 300.01;
  wall[5].checkCollisions = true;

  //wall middle center
  wall[6] = new BABYLON.MeshBuilder.CreateBox("wall middle center",
    {
      width: 10, 
      faceColors: arrRedColor, 
      height: 3, 
      depth: 0.6,
    },
    scene);
  wall[6].position.x = 0;
  wall[6].position.z = 0;
  wall[6].position.y = 4.45;
  wall[6].rotation.y = 300.01;
  wall[6].checkCollisions = true;


  //var camera = 
  createFollowCamera(scene, canvas, tank);

  console.log(tank.move);


  //set up input map
  var inputMap = {};
  scene.actionManager = new BABYLON.ActionManager(scene);
  scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, function(evt) {
    inputMap[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";

  }));
  scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger, function(evt) {
    inputMap[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";

  }));

  scene.onBeforeRenderObservable.add(() => {
    if (tank) {
      if (inputMap["w"] || inputMap["ArrowUp"]) {
        tank.moveWithCollisions(tank.frontVector.multiplyByFloats(tank.speed, tank.speed, tank.speed));
        socket.emit('move', { id: id, position: tank.position, rotation: tank.rotation})
      }
      if (inputMap["s"] || inputMap["ArrowDown"]) {
        tank.moveWithCollisions(tank.frontVector.multiplyByFloats(-tank.speed, -tank.speed, -tank.speed));
        socket.emit('move', { id: id, position: tank.position, rotation: tank.rotation})
      }
      if (inputMap["a"] || inputMap["ArrowLeft"]) {
        tank.rotation.y -= .05;
        tank.frontVector = new BABYLON.Vector3(Math.sin(tank.rotation.y), 0, Math.cos(tank.rotation.y));
        socket.emit('move', { id: id, position: tank.position, rotation: tank.rotation})
      }
      if (inputMap["d"] || inputMap["ArrowRight"]) {
        tank.rotation.y += .05;
        tank.frontVector = new BABYLON.Vector3(Math.sin(tank.rotation.y), 0, Math.cos(tank.rotation.y));
        socket.emit('move', { id: id, position: tank.position, rotation: tank.rotation})
      }
    }


  })
  return scene;
};

let createPointerLock = function(scene) {
    let canvas = scene.getEngine().getRenderingCanvas();
    canvas.addEventListener("click", event => {
      canvas.requestPointerLock = canvas.requestPointerLock || canvas.msRequestPointerLock || canvas.mozRequestPointerLock || canvas.webkitRequestPointerLock;
      if(canvas.requestPointerLock) {
        canvas.requestPointerLock();
      }
    }, false);
  }; 

// call the createScene function
var scene = createScene();
createPointerLock(scene);
// run the render loop
engine.runRenderLoop(function() {
  scene.render();
});

// the canvas/window resize event handler
window.addEventListener('resize', function() {
  engine.resize();
});
}
        )
    </script>
</body>
</html>
